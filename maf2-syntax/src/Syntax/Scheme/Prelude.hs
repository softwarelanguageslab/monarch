{-# LANGUAGE TemplateHaskell #-}
module Syntax.Scheme.Prelude(addPrelude, preludedNames) where

import Data.FileEmbed

prelude :: String
prelude = $(makeRelativeToProject "preludes/scheme.scm" >>= embedStringFile)

addPrelude :: String -> String 
addPrelude = (prelude ++)

preludedNames :: [String]
preludedNames = [
    "$pc",
    "$cmp",
    "debug",
    "halt",
    "abs",
    "append",
    "assoc",
    "assq",
    "assv",
    -- "call-with-current-continuation",
    "call-with-input-file",
    "call-with-output-file",
    "int-top",
    "caar",
    "cadr",
    "cdar",
    "cddr",
    "caaar",
    "caadr",
    "cadar",
    "cdaar",
    "caddr",
    "cddar",
    "cdadr",
    "cdddr",
    "caaaar",
    "caaadr",
    "caadar",
    "cadaar",
    "cdaaar",
    "cddaar",
    "caddar",
    "caaddr",
    "cadadr",
    "cdadar",
    "cdaadr",
    "cdddar",
    "cadddr",
    "cdaddr",
    "cddadr",
    "cddddr",
    "char>?",
    "char<=?",
    "char>=?",    
    "char-ci>?",
    "char-ci<=?",
    "char-ci>=?",
    -- "char-alphabetic?",
    -- "char-numeric?",
    "char-whitespace?",
    "equal?",
    "eqv?",
    "even?",
    "for-each",
    "gcd",
    "lcm",
    "length",
    "list",
    "list-ref",
    "list->string",
    "list->vector",
    "list-tail",
    "list?",
    "map",
    "max",
    "member",
    "memq",
    "memv",
    "min",
    "negative?",
    "newline",
    "not",
    "odd?",
    "positive?",
    "reverse",
    "size",
    "string<=?",
    "string>?",
    "string>=?",
    "string",
    "string-fill!",
    "string->list",
    "string=?",
    "string-ci=?",
    "truncate",
    "vector->list",
    "zero?",
    "foldr",
    "foldr-aux",
    "foldl",
    "foldl-aux",
    "apply",
    "ref",
    "deref",
    "ref-set",
    "void",
    "__toplevel_cons",
    "__toplevel_car",
    "__toplevel_cdr",
    "__toplevel_set-car!",
    "__toplevel_set-cdr!",
    "__toplevel_append"
    ]