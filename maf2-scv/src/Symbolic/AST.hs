{-# LANGUAGE DeriveGeneric #-}
-- | Specification of the symbolic language
-- used for encoding constraints generated by the
-- program under analysis.
module Symbolic.AST
  ( SolverResult (..),
    Formula (..),
    disjunction,
    conjunction,
    Proposition (..),
    Literal (..),
    SelectVariable (..),
    isSat,
    isUnsat,
    isUnknown,
    emptyPC,
    emptyFormula,
    PC,
  )
where

import Syntax.Scheme (Span)
import Data.Set (Set)
import Data.List (intercalate)
import qualified Data.Set as Set
import GHC.Generics
import Control.DeepSeq

-- | A literal as they appear in a source program
data Literal
  = Num !Integer
  | Rea !Double
  | Str !String
  | Boo !Bool
  | Cha !Char
  | Sym !String
  | -- | a behavior of an actor
    Beh
  | -- | a contract monitor
    Mon
  | Nil
  | Unsp
  | Actor !(Maybe Span)
  deriving (Eq, Ord, Generic)

instance NFData Literal

instance Show Literal where  
   show (Num n) = show n 
   show (Rea d) = show d
   show (Str s) = show s 
   show (Boo b) = show b 
   show (Cha c) = show c 
   show (Sym s) = s
   show Beh = "beh"
   show Mon = "mon" 
   show Nil = "()"
   show Unsp = "#u"
   show (Actor _) = "α"

-- | A proposition consists of an
-- application of a primitive predicate,
-- or of a single variable holding a particular truth value.
--
-- All variables for our propositions are universivelly
-- quantified.
data Proposition i
  = Variable !i      -- ^ a symbolic variable represent by @i@
  | Function !String -- ^ a built-in SMTlib function
  | Literal  !Literal
  | -- | assertion that the proposition's truth value is "true"
    IsTrue   !(Proposition i)
  | -- | assertion that the proposition's truth value is "false
    IsFalse  !(Proposition i)
  | -- | an atomic predicate
    Predicate   !String ![Proposition i]
  | Application !(Proposition i) ![Proposition i]
  -- | A statement that is always true
  | Tautology
   -- | Generate an unquantified fresh variable
  | Fresh
   -- | Representation of the bottom value, nothing can be derived from this and a
   -- all assertions fail
  | Bottom
  deriving (Eq, Ord, Generic)

instance (NFData i) => NFData (Proposition i)

-- | Make proposition showable
instance (Show i) => Show (Proposition i) where 
   show (Variable i)  = show i 
   show (Function f)  = f
   show (Literal lit) = show lit
   show (IsTrue p)    = "true?/v(" ++ show p ++ ")"
   show (IsFalse p)   = "false?/v(" ++ show p ++ ")"
   show Fresh         = "fresh"
   show Tautology     = "true"
   show Bottom        = "⊥"
   show (Predicate nam p) = nam ++ "(" ++ intercalate "," (map show p) ++")"
   show (Application p1 p2) = show p1 ++ "(" ++ intercalate "," (map show p2) ++ ")#"

-- | Inductively defined formulae, these include
-- conjunction, disjunction negation and atomic formulas.
data Formula i
  = Conjunction !(Set (Formula i))
  | Disjunction !(Set (Formula i))
  | Implies !(Formula i) !(Formula i)
  | Negation !(Formula i)
  | Atomic !(Proposition i)
  | Empty
  deriving (Eq, Ord, Generic)

instance NFData i => NFData (Formula i)

-- | Create a conjunction of two formulas
conjunction :: Ord i => Formula i -> Formula i -> Formula i 
conjunction (Conjunction f1) (Conjunction f2) = Conjunction $ Set.union f1 f2
conjunction f1 (Conjunction f2) = Conjunction $ Set.union (Set.singleton f1) f2
conjunction f1 f2 = Conjunction $ Set.fromList [f1, f2]

-- | Create a disjunction of two formulas
disjunction :: Ord i => Formula i -> Formula i -> Formula i 
disjunction (Disjunction f1) (Disjunction f2) = Disjunction $ Set.union f1 f2
disjunction f1 (Disjunction f2) = Disjunction $ Set.union (Set.singleton f1) f2
disjunction f1 f2 = Disjunction $ Set.fromList [f1, f2]

-- | Create an empty formula
emptyFormula :: Formula i 
emptyFormula = Empty

-- | The path condition is an unordered disjunction of formulas
type PC i = Set (Formula i)

emptyPC :: PC i 
emptyPC = Set.singleton Empty

-- | Make formulas showable
instance (Show i) => Show (Formula i) where  
   show (Conjunction fs) = intercalate " /\\ " (map show (Set.toList fs))
   show (Disjunction fs) = intercalate " \\/" (map show (Set.toList fs))
   show (Implies f1 f2) = show f1 ++ "=>" ++ show f2
   show (Negation f1) = "¬" ++ show f1 
   show (Atomic p) = "(" ++ show p ++ ")"
   show Empty = "ϵ"

-- | Select all variables in the formula
class SelectVariable v i |  v -> i where
  variables :: v -> Set i

-- | Variables can be selected from formulas
instance Ord i => SelectVariable (Formula i) i where
  variables (Conjunction fs) = Set.unions (Set.map variables fs)
  variables (Disjunction fs) = Set.unions (Set.map variables fs)
  variables (Negation f) = variables f
  variables (Implies f1 f2) = variables f1 `Set.union` variables f2
  variables (Atomic prop) = variables prop
  variables Empty = Set.empty

-- | Variables can be selected from propositions
instance (Ord i) => SelectVariable (Proposition i) i where
  variables (Variable nam) = Set.singleton nam
  variables (IsTrue prop) = variables prop
  variables (IsFalse prop) = variables prop
  variables (Predicate _ props) = mconcat (map variables props)
  variables (Literal _) = Set.empty
  variables Tautology = Set.empty
  variables Fresh = Set.empty
  variables Bottom = Set.empty
  variables (Application p1 p2) = variables p1 `Set.union` mconcat (map variables p2)
  variables (Function _) = Set.empty


-- |  The result of solving an SMT formula.
data SolverResult
  = Sat
  | Unsat
  | Unknown
  deriving (Show)

isSat :: SolverResult -> Bool
isSat Sat = True
isSat _ = False

isUnsat :: SolverResult -> Bool
isUnsat Unsat = True
isUnsat _ = False

isUnknown :: SolverResult -> Bool
isUnknown Unknown = True
isUnknown _ = False


